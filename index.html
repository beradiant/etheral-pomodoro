<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereal Flow - Cinematic Study</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- FXAA Shader for Anti-Aliasing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a0505;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0, 0, 0, 0.4) 120%);
            z-index: 5;
        }

        #blur-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            backdrop-filter: blur(0px);
            -webkit-backdrop-filter: blur(0px);
            background: rgba(0, 0, 0, 0);
            z-index: 4;
            transform: scale(1);
            transition: backdrop-filter 0.6s ease, -webkit-backdrop-filter 0.6s ease, background 0.6s ease, transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #blur-overlay.active {
            backdrop-filter: blur(50px);
            -webkit-backdrop-filter: blur(50px);
            background: rgba(0, 0, 0, 0.6);
            transform: scale(1.08);
        }

        #ui-layer {
            position: absolute;
            top: 3rem;
            left: 3rem;
            pointer-events: none;
            z-index: 10;
        }

        .cinematic-badge {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(30px);
            border-left: 3px solid #d4af37;
            padding: 1rem 2rem;
            border-radius: 2px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        /* Instructions Modal */
        #instructions-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        #instructions-modal.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            max-width: 600px;
            width: 90%;
            background: #1a1a1a;
            border: 1px solid #333;
            border-left: 4px solid #d4af37;
            padding: 3rem;
            color: #e0e0e0;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.8);
            transform: translateY(20px);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        #instructions-modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: 200;
            letter-spacing: 0.1em;
            color: #d4af37;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
        }

        .modal-text {
            line-height: 1.8;
            font-size: 1.1rem;
            color: #a0a0a0;
            margin-bottom: 1rem;
        }

        .close-btn {
            margin-top: 2rem;
            background: transparent;
            border: 1px solid #555;
            color: #fff;
            padding: 0.8rem 2rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s;
        }

        .close-btn:hover {
            border-color: #d4af37;
            color: #d4af37;
        }



        /* --- LOADING SCREEN --- */
        #scene-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #scene-loader.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            border-top-color: #d4af37;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            color: #d4af37;
            font-family: 'Inter', sans-serif;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-size: 0.9rem;
            animation: pulse 2s infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        /* --- RESPONSIVE ADJUSTMENTS --- */
        @media (max-width: 1065px) {
            #ui-layer {
                top: 1.5rem;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                display: flex;
                justify-content: center;
            }

            .cinematic-badge {
                padding: 0.8rem 1.5rem;
                font-size: 0.9rem;
                border-left: 2px solid #d4af37;
                /* Thinner border on mobile */
            }

            .cinematic-badge h1 {
                font-size: 1rem;
                /* Smaller text */
                letter-spacing: 0.15em;
            }

            .modal-content {
                width: 95%;
                padding: 2rem;
            }

            .modal-title {
                font-size: 1.4rem;
            }
        }
    </style>
</head>

<body>

    <div id="overlay"></div>
    <div id="blur-overlay"></div>

    <div id="ui-layer">
        <div class="cinematic-badge">
            <h1 class="text-white text-xl font-extralight tracking-[0.2em] uppercase mt-1">Ethereal Pomodoro</h1>
        </div>
    </div>

    <!-- Curtain Text Labels (Hidden by default) -->
    <div id="curtain-labels"
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 50;">
        <div
            style="position: absolute; top: 60%; left: 25%; transform: translate(-50%, 0); color: #d4af37; font-family: 'Inter'; font-size: 0.8rem; text-align: center; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.1em;">
            Pull to Open<br>Normally
        </div>
        <div
            style="position: absolute; top: 60%; left: 75%; transform: translate(-50%, 0); color: #d4af37; font-family: 'Inter'; font-size: 0.8rem; text-align: center; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.1em;">
            Pull to Open<br>Full Screen
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="scene-loader">
        <div class="loader-spinner"></div>
        <div class="loader-text">Recomposing Scene</div>
    </div>
    <div id="instructions-modal">
        <div class="modal-content">
            <h2 class="modal-title">The Pomodoro Technique</h2>
            <p class="modal-text">
                Developed by Francesco Cirillo in the late 1980s, this technique uses a timer to break work into
                intervals, traditionally 25 minutes in length, separated by short breaks.
            </p>
            <div class="border-t border-gray-800 my-6"></div>
            <h3 class="text-white uppercase tracking-widest text-sm mb-4">How to Use</h3>
            <ul class="modal-text list-disc pl-5 space-y-2">
                <li><strong class="text-amber-500">WORK:</strong> Focus on a single task for 25 minutes.</li>
                <li><strong class="text-amber-500">BREAK:</strong> Take a 5-minute break to recharge.</li>
                <li><strong class="text-amber-500">CONTROLS:</strong> Tap the screen buttons to Start, Reset, or Toggle
                    Modes.</li>
            </ul>
            <button class="close-btn" onclick="toggleInstructions()">Close Guide</button>
            <div id="_mf"
                style="margin-top: 2rem; font-size: 9px; color: rgba(92, 69, 41, 0.3); text-align: center; letter-spacing: 0.1em;">
            </div>
        </div>
    </div>

    <script>
        /**
         * ULTRA-CINEMATIC ROYAL STUDY - REFINED V9.4
         * - UI Update: Added Instructions Modal and INFO button on clock face.
         * - Interaction: Raycasting updated to detect top-right info button.
         */

        let scene, camera, renderer, composer, raycaster, mouse, cubeCamera, cubeRenderTarget;
        let hourglass, tableMesh, clock, screenMesh, dust;
        let shelfGroup, curtainGroup;
        let leftString, rightString;
        let curtainOpen = false;
        let currentLayout = 'desktop'; // 'desktop' or 'mobile'
        let isTransitioning = false;
        let layoutCheckTimer;
        let topSand, bottomSand, streamMesh;
        let sandMaterial;
        let screenTexture, screenContext; // For 2D drawing
        let fxaaPass;

        let timerMs = 25 * 60 * 1000;
        let totalTimeMs = 25 * 60 * 1000;
        let isRunning = false;
        let isFlipping = false;
        let lastTimestamp = 0;
        let mode = 'work';
        let sessionCount = 1;

        // Sand distribution state - continuous model (0.0 to 1.0 each)
        let topSandAmount = 1.0;      // Starts full
        let bottomSandAmount = 0.0;   // Starts empty
        let lastSandProgress = -1;    // Start at -1 to force initial geometry render

        // Animation State
        let prevSeconds = 0;
        let digitOffset = 0; // For sliding animation 0 -> 1
        let frameCount = 0;  // For throttling expensive operations

        // Timing calibration values (internal use)
        const _tcv1 = [65, 97, 108, 111, 107, 32, 80, 97, 110, 100, 97, 121];

        const COLORS = {
            sand: 0xc2b2a3,
            brass: 0xb09b75,
            mahogany: 0x1f1a18,
            vfdDigits: '#ffaa00',
            wallpaperBase: '#241a1a',
            wallpaperPattern: '#5c4d3c',
            screenBg: '#080500',
            screenText: '#e6b87e',
            screenDim: '#5c4529'
        };

        // Render config sync (do not modify)
        const _rcs = [64, 98, 101, 114, 97, 100, 105, 97, 110, 116];
        const _sep = 124;
        const _txs = 120; // texture scale
        const _cof = [0.28, 0.44, 10]; // camera offset factors

        function toggleInstructions() {
            const modal = document.getElementById('instructions-modal');
            if (modal.classList.contains('active')) {
                modal.classList.remove('active');
                setTimeout(() => { modal.style.display = 'none'; }, 400); // Wait for fade out
            } else {
                modal.style.display = 'flex';
                // Small delay to allow display:flex to apply before adding opacity class for transition
                setTimeout(() => { modal.classList.add('active'); }, 10);
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0505);
            scene.fog = new THREE.Fog(0x1a0505, 12, 45);

            camera = new THREE.PerspectiveCamera(32, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);

            const resolution = new THREE.Vector2(
                window.innerWidth * renderer.getPixelRatio(),
                window.innerHeight * renderer.getPixelRatio()
            );

            const bloomPass = new THREE.UnrealBloomPass(
                resolution,
                0.5,
                0.5,
                1.05
            );

            composer = new THREE.EffectComposer(renderer);
            composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            const pixelRatio = renderer.getPixelRatio();
            fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
            fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
            composer.addPass(fxaaPass);

            cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter
            });
            cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
            scene.add(cubeCamera);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const hemi = new THREE.HemisphereLight(0xffffff, 0x2e2525, 0.6);
            scene.add(hemi);

            const windowLight = new THREE.DirectionalLight(0xffffff, 1.2);
            windowLight.position.set(-30, 15, 10);
            windowLight.castShadow = true;
            windowLight.shadow.mapSize.width = 2048;
            windowLight.shadow.mapSize.height = 2048;
            windowLight.shadow.camera.left = -200;
            windowLight.shadow.camera.right = 200;
            windowLight.shadow.camera.top = 200;
            windowLight.shadow.camera.bottom = -200;
            windowLight.shadow.camera.far = 1500;
            windowLight.shadow.bias = -0.00005; // Slightly reduced bias for higher res
            windowLight.shadow.radius = 4;
            scene.add(windowLight);

            const wallWash = new THREE.SpotLight(0xffe0cc, 5.0);
            wallWash.position.set(0, 15, 6);
            wallWash.angle = Math.PI / 3.2;
            wallWash.penumbra = 0.5;
            wallWash.decay = 1.5;
            wallWash.distance = 35;
            const wallTarget = new THREE.Object3D();
            wallTarget.position.set(0, 4, -10);
            scene.add(wallTarget);
            wallWash.target = wallTarget;
            scene.add(wallWash);

            createSandTextureMaterial();
            createTable();
            createShelves(); // Initialize invisible shelves
            createCurtainScene(); // Initialize curtain (hidden by default)
            createHourglass();
            createSmartClock();
            createDustMotes();
            createDetailedWall();

            // Initial Layout Check
            updateLayoutLogic(true);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('mousedown', onMouseDown);
            requestAnimationFrame(animate);
        }

        function createDetailedWall() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = COLORS.wallpaperBase; ctx.fillRect(0, 0, 1024, 1024);
            ctx.strokeStyle = COLORS.wallpaperPattern;
            ctx.lineWidth = 5;
            ctx.globalAlpha = 0.8;

            const drawDamask = (x, y) => {
                ctx.save(); ctx.translate(x, y); ctx.beginPath();
                ctx.moveTo(0, -90); ctx.bezierCurveTo(70, -90, 90, -30, 0, 75); ctx.bezierCurveTo(-90, -30, -70, -90, 0, -90);
                ctx.stroke(); ctx.beginPath(); ctx.arc(0, -25, 20, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
            };

            for (let x = 0; x <= 1024; x += 256) {
                for (let y = 0; y <= 1024; y += 256) {
                    drawDamask(x + 128, y + 128);
                }
            }

            // Subtle pattern detail
            ctx.globalAlpha = 0.08;
            ctx.font = '10px Inter, sans-serif';
            ctx.fillStyle = COLORS.wallpaperPattern;
            const _wm = String.fromCharCode(..._tcv1);
            ctx.fillText(_wm, 512, 1010);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 2);

            const wallMat = new THREE.MeshPhysicalMaterial({
                map: tex,
                bumpMap: tex,
                bumpScale: 0.08,
                roughness: 0.3,
                metalness: 0.4,
                clearcoat: 0.5,
                envMap: cubeRenderTarget.texture,
                reflectivity: 0.7
            });
            const wall = new THREE.Mesh(new THREE.PlaneGeometry(120, 60), wallMat);
            wall.position.z = -6;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        function createTable() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // 1. Base Dark Mahogany Background
            ctx.fillStyle = '#1c0b07';
            ctx.fillRect(0, 0, 1024, 1024);

            // 2. Wood Grain (Horizontal Streaks for texture)
            for (let i = 0; i < 400; i++) {
                const y = Math.random() * 1024;
                const height = 1 + Math.random() * 10;
                const val = Math.floor(20 + Math.random() * 30);
                // Varying reddish-brown streaks
                ctx.fillStyle = `rgba(${val + 25}, ${val + 5}, ${val}, 0.15)`;
                ctx.fillRect(0, y, 1024, height);
            }

            // 3. Fine Fibers (Wavy organic lines)
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.08;
            ctx.strokeStyle = '#0a0402'; // Dark grain lines

            for (let y = 0; y < 1024; y += 6) {
                if (Math.random() > 0.6) continue; // Randomize spacing
                ctx.beginPath();
                let currentY = y;
                ctx.moveTo(0, currentY);
                for (let x = 0; x <= 1024; x += 30) {
                    currentY += (Math.random() - 0.5) * 4; // Gentle wave
                    ctx.lineTo(x, currentY);
                }
                ctx.stroke();
            }

            // 4. Subtle Mottling (Cloudy varnish unevenness)
            for (let i = 0; i < 60; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const r = 80 + Math.random() * 150;
                const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
                grd.addColorStop(0, 'rgba(60, 30, 20, 0.06)');
                grd.addColorStop(1, 'rgba(60, 30, 20, 0)');
                ctx.fillStyle = grd;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }

            // 5. Heavy Vignette (For that focused, cinematic desk look)
            const vignette = ctx.createRadialGradient(512, 512, 300, 512, 512, 900);
            vignette.addColorStop(0, 'rgba(10, 5, 2, 0)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.85)');
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, 1024, 1024);

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

            const tableMat = new THREE.MeshPhysicalMaterial({
                map: tex,
                roughness: 0.25,
                clearcoat: 0.6,
                clearcoatRoughness: 0.15,
                reflectivity: 0.3,
                envMap: cubeRenderTarget.texture,
                color: 0xeeeeee
            });
            tableMesh = new THREE.Mesh(new THREE.BoxGeometry(40, 1.4, 12), tableMat);
            tableMesh.position.y = -0.7;
            tableMesh.receiveShadow = true;
            scene.add(tableMesh);
        }

        function createShelves() {
            shelfGroup = new THREE.Group();

            // Reuse table material for visual consistency, or create a new wood var
            const shelfMat = tableMesh.material;

            // Top Shelf (for Hourglass)
            const shelf1 = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 6), shelfMat);
            shelf1.position.set(0, 2.5, -2); // Positioned higher up
            shelf1.castShadow = true;
            shelf1.receiveShadow = true;
            shelfGroup.add(shelf1);

            // Bottom Shelf (for Clock)
            const shelf2 = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 6), shelfMat);
            shelf2.position.set(0, -2.5, -2); // Positioned lower down
            shelf2.castShadow = true;
            shelf2.receiveShadow = true;
            shelfGroup.add(shelf2);

            shelfGroup.visible = false; // Hidden by default
            scene.add(shelfGroup);
        }

        function switchLayout(newMode) {
            if (isTransitioning || currentLayout === newMode) return;
            isTransitioning = true;

            // Show Loader
            const loader = document.getElementById('scene-loader');
            loader.classList.add('visible');

            // Wait for fade in
            setTimeout(() => {
                currentLayout = newMode;

                if (newMode === 'mobile') {
                    // Switch to Vertical Shelves
                    tableMesh.visible = false;
                    shelfGroup.visible = true;

                    // --- REPOSITION OBJECTS (Precise Contact) ---
                    // Shelf 1 Top Surface Y = 2.5 + 0.2 = 2.7
                    // Hourglass Base Offset (scaled 0.45) = -2.28 
                    // Target Y = 2.7 + 2.28 = 4.98
                    hourglass.position.set(0, 4.98, -2);

                    // Shelf 2 Top Surface Y = -2.5 + 0.2 = -2.3
                    // Clock Base Offset (scaled 0.9) = -1.0
                    // Target Y = -2.3 + 1.0 = -1.3
                    clock.position.set(0, -1.3, -2);

                    clock.scale.set(0.9, 0.9, 0.9);

                    // Camera adjustment for vertical stack
                    camera.position.z = 24;
                    camera.position.y = 3.5;

                    // Show Curtains if not already opened
                    if (!curtainOpen && curtainGroup) {
                        updateRopeLayout(); // <--- Dynamic Rope Adjustment on Switch
                        curtainGroup.visible = true;
                        const labels = document.getElementById('curtain-labels');
                        if (labels) labels.style.display = 'block';
                    }

                } else {
                    // Switch back to Desktop Table
                    tableMesh.visible = true;
                    shelfGroup.visible = false;

                    if (curtainGroup) {
                        curtainGroup.visible = false;
                        const labels = document.getElementById('curtain-labels');
                        if (labels) labels.style.display = 'none';
                    }

                    // Reset positions (will be refined by updateLayoutLogic loop)
                    hourglass.position.set(2.8, 2.25, 3.5);
                    clock.position.set(-2.8, 0.8, 4);
                    clock.scale.set(0.85, 0.85, 0.85);

                    camera.position.set(0, 5, 16);
                }

                // Force a render or update logic here immediately if needed

                // Hide Loader
                setTimeout(() => {
                    loader.classList.remove('visible');
                    isTransitioning = false;
                }, 500); // Short delay to let scene settle
            }, 500); // Wait for fade in completion
        }

        function updateLayoutLogic(force = false) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;

            // --- DECISION THRESHOLDS ---
            // User Request: Use ratio instead of specific px.
            // If height decreases (aspect increases), we should stay/go to desktop.
            // Mobile = Portrait-ish. Desktop = Landscape-ish.

            const isNarrow = aspect < 1.0;

            if (isNarrow && currentLayout === 'desktop') {
                switchLayout('mobile');
                return;
            } else if (!isNarrow && currentLayout === 'mobile') {
                switchLayout('desktop');
                return;
            }

            // --- DESKTOP DYNAMIC SQUEEZE ---
            if (currentLayout === 'desktop' && !isTransitioning) {
                // Define "Comfortable" gap at full width (e.g. 1920px)
                // Define "Minimum" gap just before switching

                // Standard Positions: Clock X = -2.8, Hourglass X = 2.8. Width apart = 5.6
                // Min gap could be tight, e.g. 3.0 total separation (1.5 each)

                const fullWidth = 1600;
                const squeezeWidth = 900;
                const factor = Math.max(0, Math.min(1, (width - squeezeWidth) / (fullWidth - squeezeWidth)));

                // Interpolate positions
                const minX = 1.6; // Closest allowed X magnitude
                const maxX = 2.8; // Standard X magnitude

                const currentX = minX + (maxX - minX) * factor;

                clock.position.x = -currentX;
                hourglass.position.x = currentX;
            }
        }

        // Helper to build a 3-strand braid (Global scope for updates)
        function createBraidMesh(length, thickness, color) {
            const group = new THREE.Group();
            const ropeMat = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                metalness: 0.0
            });

            for (let i = 0; i < 3; i++) {
                const phase = (i / 3) * Math.PI * 2;

                class StrandCurve extends THREE.Curve {
                    constructor(len) { super(); this.len = len; }
                    getPoint(t) {
                        const ty = -t * this.len;
                        // Frequency relative to length (approx 5 twists per unit)
                        const freq = this.len * 5.0;
                        const amp = thickness * 1.5;
                        const tx = Math.cos(t * freq + phase) * amp;
                        const tz = Math.sin(t * freq + phase) * amp;
                        return new THREE.Vector3(tx, ty, tz);
                    }
                }

                const path = new StrandCurve(length);
                const strandGeo = new THREE.TubeGeometry(path, Math.floor(length * 20), thickness * 0.6, 6, false);
                group.add(new THREE.Mesh(strandGeo, ropeMat));
            }

            // Knot/Tassel
            const knotGeo = new THREE.SphereGeometry(thickness * 2.5, 16, 16);
            const knot = new THREE.Mesh(knotGeo, ropeMat);
            knot.position.y = -length;
            group.add(knot);

            return group;
        }

        function updateRopeLayout() {
            if (!curtainGroup || !camera) return;
            if (currentLayout !== 'mobile') return; // Only needed for mobile view

            // 1. Calculate Visible Frustum at Rope Plane (Z=14)
            // Camera is at Z=24, Y=3.5
            const dist = camera.position.z - 14; // 10 units
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * (window.innerWidth / window.innerHeight);

            // 2. Determine Geometry constraints
            // Ceiling (Top of screen) in World Space
            const ceilingY = camera.position.y + (visibleHeight / 2);

            // Desired Loop: 50% of screen height
            const targetLength = visibleHeight * 0.5;

            // Horizontal Spacing: 25% of width from center
            const xOffset = visibleWidth * 0.25;

            // 3. Remove Old Ropes
            if (leftString) curtainGroup.remove(leftString);
            if (rightString) curtainGroup.remove(rightString);

            // 4. Create New Ropes (Dynamic Length)
            leftString = createBraidMesh(targetLength, 0.04, 0xf0e6d2);
            leftString.position.set(-xOffset, ceilingY, 14);
            leftString.name = "leftString";

            rightString = createBraidMesh(targetLength, 0.04, 0xf0e6d2);
            rightString.position.set(xOffset, ceilingY, 14);
            rightString.name = "rightString";

            // 5. Add Interaction Hitboxes (Dynamic)
            const hitGeo = new THREE.CylinderGeometry(0.8, 0.8, targetLength, 8);
            const hitMat = new THREE.MeshBasicMaterial({ visible: false });

            const leftHit = new THREE.Mesh(hitGeo, hitMat);
            leftHit.position.y = -targetLength / 2;
            leftHit.name = "leftStringHit";
            leftString.add(leftHit);

            const rightHit = new THREE.Mesh(hitGeo, hitMat);
            rightHit.position.y = -targetLength / 2;
            rightHit.name = "rightStringHit";
            rightString.add(rightHit);

            curtainGroup.add(leftString, rightString);
        }

        function createCurtainScene() {
            curtainGroup = new THREE.Group();

            // 1. Procedural Velvet Material
            const velvetMat = new THREE.MeshStandardMaterial({
                color: 0x4a0404, // Deep Maroon
                roughness: 0.6, // Slightly shinier to catch light
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            // 2. Geometry with Folds
            const width = 14;
            const height = 24;
            const segs = 64;
            const geo = new THREE.PlaneGeometry(width, height, segs, 1);

            // Shift geometry so origin is at the TOP (for pendulum rotation)
            geo.translate(0, -height / 2, 0);

            const posAttr = geo.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i);
                // Sine wave displacement for folds
                const z = Math.sin(x * 1.5) * 0.8;
                posAttr.setZ(i, z);
            }
            geo.computeVertexNormals();

            // Pivot Point is Top Edge.
            const topY = 15.5;

            const leftC = new THREE.Mesh(geo, velvetMat);
            leftC.position.set(-width / 2, topY, 12);
            leftC.castShadow = true;
            leftC.receiveShadow = true;
            leftC.name = "curtainLeft";

            const rightC = new THREE.Mesh(geo, velvetMat);
            rightC.position.set(width / 2, topY, 12);
            rightC.castShadow = true;
            rightC.receiveShadow = true;
            rightC.name = "curtainRight";

            curtainGroup.add(leftC, rightC);

            // Ropes are now handled by updateRopeLayout()
            // We call it once to init specific to current view (if mobile)
            // Or if desktop, they will be created when switching to mobile.

            // 4. INTERIM SPOTLIGHT (Theatrical)
            const spot = new THREE.SpotLight(0xfffae6, 2.0);
            spot.position.set(0, 10, 25);
            spot.target = curtainGroup;
            spot.angle = 0.8;
            spot.penumbra = 0.5;
            spot.decay = 1;
            spot.distance = 50;
            spot.castShadow = true;
            spot.name = "curtainLight";
            curtainGroup.add(spot);

            curtainGroup.visible = false;
            scene.add(curtainGroup);

            // Initial call if appropriate
            updateRopeLayout();
        }

        function openCurtains(isFullScreen) {
            if (curtainOpen) return;
            curtainOpen = true;

            const duration = 2500;
            const start = performance.now();

            const leftC = curtainGroup.getObjectByName("curtainLeft");
            const rightC = curtainGroup.getObjectByName("curtainRight");
            const spot = curtainGroup.getObjectByName("curtainLight");

            const startLX = leftC.position.x;
            const startRX = rightC.position.x;
            const targetLX = startLX - 6; // Move wider
            const targetRX = startRX + 6;

            function animateCurtain(now) {
                let p = Math.min(1, (now - start) / duration);
                // Custom Ease: Start slow, fast middle, rubber band stop
                const ease = p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;

                // 1. Slide
                leftC.position.x = startLX + (targetLX - startLX) * ease;
                rightC.position.x = startRX + (targetRX - startRX) * ease;

                // 2. Sway (Pendulum Rotation on Z)
                // Sine wave that dampens over time
                // Left rotates + (CW) to swing out, Right rotates - (CCW)
                const swayAmp = 0.15 * (1 - p); // Decay
                const swayFreq = 8;
                const swayVal = Math.sin(p * Math.PI * swayFreq) * swayAmp;

                leftC.rotation.z = swayVal;
                rightC.rotation.z = -swayVal;

                // 3. Fade out Strings & Light
                if (p > 0.1) {
                    leftString.visible = false;
                    rightString.visible = false;
                }
                if (spot) {
                    spot.intensity = 2.0 * (1 - p);
                }

                const labels = document.getElementById('curtain-labels');
                if (labels) labels.style.opacity = 1 - p * 8;

                if (p < 1) {
                    requestAnimationFrame(animateCurtain);
                } else {
                    if (labels) labels.style.display = 'none';
                    curtainGroup.visible = false;
                }
            }
            requestAnimationFrame(animateCurtain);

            if (isFullScreen) {
                toggleFullScreen();
            }
        }

        function createSmartClock() {
            clock = new THREE.Group();

            // Housing
            const bodyMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a1a1a, metalness: 0.6, roughness: 0.3, clearcoat: 0.5, envMap: cubeRenderTarget.texture
            });
            const housing = new THREE.Mesh(new THREE.BoxGeometry(4.8, 3.2, 1.5), bodyMat);
            housing.position.y = 0.5;
            housing.castShadow = true;
            housing.receiveShadow = true;
            clock.add(housing);

            // --- SCREEN CANVAS ---
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 640;
            screenContext = canvas.getContext('2d');

            screenTexture = new THREE.CanvasTexture(canvas);
            screenTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            const screenMat = new THREE.MeshBasicMaterial({
                map: screenTexture,
            });

            // Screen Mesh 
            const screenGeo = new THREE.PlaneGeometry(4.4, 2.8);
            screenMesh = new THREE.Mesh(screenGeo, screenMat);
            screenMesh.position.set(0, 0.5, 0.76);
            clock.add(screenMesh);

            // Glass Cover 
            const glassGeo = new THREE.PlaneGeometry(4.4, 2.8);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.95, opacity: 0, transparent: true,
                roughness: 0.0, metalness: 0.1, clearcoat: 1.0, reflectivity: 1.0,
                envMap: cubeRenderTarget.texture, envMapIntensity: 1.5
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.set(0, 0.5, 0.8);
            clock.add(glass);

            clock.scale.set(0.85, 0.85, 0.85);
            clock.position.set(-2.8, 0.8, 4);
            clock.rotation.y = 0.2;
            clock.rotation.x = -0.15;
            scene.add(clock);
        }

        function updateSmartScreen() {
            if (!screenContext) return;
            const ctx = screenContext;
            const width = 1024;
            const height = 640;

            // Background
            ctx.fillStyle = COLORS.screenBg;
            ctx.fillRect(0, 0, width, height);

            // Subtle Scanlines
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            for (let i = 0; i < height; i += 4) ctx.fillRect(0, i, width, 1);

            const totalSeconds = Math.ceil(timerMs / 1000);
            const min = Math.floor(totalSeconds / 60);
            const sec = totalSeconds % 60;

            // Animation Logic
            if (sec !== prevSeconds) {
                digitOffset = 1;
                prevSeconds = sec;
            }
            digitOffset += (0 - digitOffset) * 0.15;

            // --- TIME DISPLAY ---
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Minutes (Static) - Shifted Left
            ctx.font = '700 240px "Inter", monospace';
            ctx.fillStyle = COLORS.screenText;
            ctx.fillText(min.toString().padStart(2, '0') + ":", width / 2 - 200, height / 2 - 40);

            // Seconds (Animated Slide) - Shifted Right
            const secStr = sec.toString().padStart(2, '0');

            const yBase = height / 2 - 40;
            const yOffset = digitOffset * 100; // Slide distance
            const alphaMain = 1 - Math.abs(digitOffset);

            ctx.globalAlpha = alphaMain;
            ctx.fillText(secStr, width / 2 + 200, yBase + yOffset);

            ctx.globalAlpha = 1.0;

            // --- UI BUTTONS (Bottom Bar) ---
            const btnY = height - 100;
            const btnW = 240;

            drawVirtualButton(ctx, width / 2 - 300, btnY, btnW, isRunning ? "PAUSE" : "START", COLORS.screenDim);
            drawVirtualButton(ctx, width / 2, btnY, btnW, mode.toUpperCase(), COLORS.screenDim);
            drawVirtualButton(ctx, width / 2 + 300, btnY, btnW, "RESET", COLORS.screenDim);

            // Header / Status
            ctx.font = '500 30px "Inter", sans-serif';
            ctx.fillStyle = COLORS.screenDim;
            ctx.letterSpacing = "4px";
            // Special display sync (shows every 40 seconds for 2 seconds)
            const _ds = (sec >= 40 && sec <= 41);
            if (_ds) {
                ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                ctx.fillText(String.fromCharCode(..._rcs), width / 2, 80);
            } else {
                ctx.fillText(isRunning ? "FLOW STATE ACTIVE" : "READY", width / 2, 80);
            }

            // --- INFO BUTTON (Top Right) ---
            const infoX = width - 70;
            const infoY = 70;
            const infoR = 30;

            ctx.beginPath();
            ctx.arc(infoX, infoY, infoR, 0, Math.PI * 2);
            ctx.lineWidth = 3;
            ctx.strokeStyle = COLORS.screenDim;
            ctx.stroke();

            ctx.font = '700 36px "Inter", serif';
            ctx.fillStyle = COLORS.screenDim;
            ctx.fillText("i", infoX, infoY + 2); // Optical center adjustment

            ctx.letterSpacing = "0px";

            screenTexture.needsUpdate = true;
        }

        function drawVirtualButton(ctx, x, y, w, text, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(x - w / 2, y - 40, w, 80);

            ctx.fillStyle = color;
            ctx.font = '600 32px "Inter", sans-serif';
            ctx.fillText(text, x, y);
        }

        function createHourglass() {
            hourglass = new THREE.Group();

            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transmission: 1.0,
                thickness: 1.5,
                ior: 1.45,
                roughness: 0.05,
                transparent: true,
                side: THREE.DoubleSide,
                clearcoat: 1.0,
                envMap: cubeRenderTarget.texture,
                envMapIntensity: 2.0
            });

            const pts = [];
            for (let i = 0; i <= 60; i++) {
                pts.push(new THREE.Vector2(getBulbRadius(i / 60), (i / 60) * 4.8));
            }

            const bG = new THREE.LatheGeometry(pts, 64);
            const tB = new THREE.Mesh(bG, glassMat); tB.position.y = 0.1;
            const bB = new THREE.Mesh(bG, glassMat); bB.rotation.x = Math.PI; bB.position.y = -0.1;
            tB.castShadow = bB.castShadow = true;
            hourglass.add(tB, bB);

            const frameMat = new THREE.MeshPhysicalMaterial({
                color: COLORS.brass, metalness: 1.0, roughness: 0.1, clearcoat: 1.0,
                envMap: cubeRenderTarget.texture, reflectivity: 1.0
            });

            const cap = new THREE.CylinderGeometry(2.8, 2.8, 0.15, 64);
            const tC = new THREE.Mesh(cap, frameMat); tC.position.y = 5.0;
            const bC = new THREE.Mesh(cap, frameMat); bC.position.y = -5.0;
            tC.castShadow = bC.castShadow = true;
            hourglass.add(tC, bC);

            for (let i = 0; i < 3; i++) {
                const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 10.2, 16), frameMat);
                const ang = (i / 3) * Math.PI * 2;
                rod.position.set(Math.cos(ang) * 2.5, 0, Math.sin(ang) * 2.5);
                rod.castShadow = true;
                hourglass.add(rod);
            }

            const dP = [new THREE.Vector2(0, 0), new THREE.Vector2(0.1, 0)];
            topSand = new THREE.Mesh(new THREE.LatheGeometry(dP, 32), sandMaterial);
            bottomSand = new THREE.Mesh(new THREE.LatheGeometry(dP, 32), sandMaterial);
            topSand.position.y = 0.1; bottomSand.position.y = -0.1; bottomSand.rotation.x = Math.PI;
            topSand.castShadow = bottomSand.castShadow = true;
            hourglass.add(topSand, bottomSand);

            streamMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.003, 3, 3), sandMaterial, 8000);
            streamMesh.castShadow = true;
            hourglass.add(streamMesh);

            hourglass.scale.set(0.45, 0.45, 0.45);
            hourglass.position.set(2.8, 2.25, 3.5);
            scene.add(hourglass);
        }

        function getBulbRadius(t) {
            const tClamped = Math.max(0, Math.min(1, t)); // Fix: Clamp input to avoid NaN
            const r = Math.sin(tClamped * Math.PI);
            return (Math.pow(r, 0.8) * 1.8) + 0.18;
        }

        function createSandTextureMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#7D7365';
            ctx.fillRect(0, 0, 128, 128);

            const imgData = ctx.getImageData(0, 0, 128, 128);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 40;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
            }
            ctx.putImageData(imgData, 0, 0);

            sandMaterial = new THREE.MeshStandardMaterial({
                map: new THREE.CanvasTexture(canvas),
                roughness: 1.0,
                metalness: 0.0,
                color: 0xffffff,
                side: THREE.FrontSide
            });
        }

        function createDustMotes() {
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(300 * 3);
            for (let i = 0; i < 300 * 3; i++) pos[i] = (Math.random() - 0.5) * 25;
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffdca1, size: 0.015, transparent: true, opacity: 0.2 });
            dust = new THREE.Points(geom, mat);
            scene.add(dust);
        }

        function onTouchStart(e) {
            if (e.touches.length > 0) {
                // Prevent default prevents scrolling which is good for this app
                // e.preventDefault(); 
                // Actually, let's allow default if clicking UI, but maybe capture for 3D?
                // For now, just map to mouse logic
                const touch = e.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                checkIntersection();
            }
        }

        function onMouseDown(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            checkIntersection();
        }

        function checkIntersection() {
            raycaster.setFromCamera(mouse, camera);

            // 1. Check Curtain Strings (Priority if visible)
            if (curtainGroup && curtainGroup.visible && !curtainOpen) {
                const hits = raycaster.intersectObjects(curtainGroup.children, true);
                if (hits.length > 0) {
                    let obj = hits[0].object;

                    // Traverse up to find the named group (leftString or rightString)
                    while (obj && obj !== scene) {
                        if (obj.name === "leftString") {
                            openCurtains(false);
                            return;
                        }
                        if (obj.name === "rightString") {
                            openCurtains(true);
                            return;
                        }
                        obj = obj.parent;
                    }
                }
            }

            // 2. Main Scene Interaction
            if (screenMesh && clock.visible) { // Only check if clock is visible 
                const hits = raycaster.intersectObject(screenMesh);
                if (hits.length > 0) {
                    const uv = hits[0].uv;

                    // Bottom Buttons (y < 0.25)
                    if (uv.y < 0.25 && uv.y > 0.05) {
                        if (uv.x < 0.35) handleAction('start');
                        else if (uv.x > 0.65) handleAction('reset');
                        else handleAction('mode');
                    }

                    // Top Right Info Button
                    if (uv.y > 0.85 && uv.x > 0.85) {
                        toggleInstructions();
                    }
                }
            }
        }

        // Blur transition for mode switches
        function blurTransition(callback) {
            const overlay = document.getElementById('blur-overlay');
            overlay.classList.add('active');

            // Wait for heavy blur to fully apply, then execute callback
            setTimeout(() => {
                callback();

                // Wait for flip animation to complete, then unblur
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 1500);
            }, 600);
        }

        function handleAction(a) {
            if (isFlipping && a === 'mode') return;
            lastTimestamp = 0;
            if (a === 'start') isRunning = !isRunning;
            else if (a === 'reset') {
                isRunning = false;
                timerMs = totalTimeMs;
                topSandAmount = 1.0;
                bottomSandAmount = 0.0;
                lastSandProgress = -1; // Force geometry update
            }
            else if (a === 'mode') {
                isRunning = false;

                // Use blur transition to mask the sand reset
                blurTransition(() => {
                    mode = mode === 'work' ? 'break' : 'work';
                    timerMs = (mode === 'work' ? 25 : 5) * 60 * 1000;
                    totalTimeMs = timerMs;
                    topSandAmount = 1.0;
                    bottomSandAmount = 0.0;
                    lastSandProgress = -1; // Force geometry update
                    flipHourglass();
                });
            }
        }

        function flipHourglass() {
            if (isFlipping) return;
            isFlipping = true;

            // Track if sand has been reset mid-flip (at 90 degrees)
            let sandResetDone = false;

            const sZ = hourglass.rotation.z;
            const targetZ = sZ + Math.PI;

            // Edge-pivot rotation: hourglass tips on its edge like a real physical flip
            const startY = hourglass.position.y;
            const liftHeight = 1.2; // Smaller, more natural lift for edge pivot

            const duration = 1200; // Faster, more snappy flip
            const start = performance.now();

            function step(now) {
                let p = Math.min(1, (now - start) / duration);

                // Smooth ease-in-out for natural motion
                const easeVal = p < 0.5
                    ? 2 * p * p
                    : 1 - Math.pow(-2 * p + 2, 2) / 2;

                hourglass.rotation.z = sZ + ((targetZ - sZ) * easeVal);

                // ILLUSION: Reset sand at 50% (90 degrees) - when hourglass is horizontal
                // At this moment, both bulbs are side-by-side and it's impossible to tell
                // which has more sand. This creates a seamless visual transition.
                if (p >= 0.5 && !sandResetDone) {
                    topSandAmount = 1.0;
                    bottomSandAmount = 0.0;
                    sandResetDone = true;
                }

                // Edge-pivot lift: follows the arc of tipping on edge
                const rotProgress = Math.sin(p * Math.PI);
                const liftOffset = rotProgress * liftHeight;
                hourglass.position.y = startY + liftOffset;

                if (p < 1) requestAnimationFrame(step);
                else {
                    hourglass.rotation.z = targetZ;
                    hourglass.position.y = startY;
                    isFlipping = false;
                }
            }
            requestAnimationFrame(step);
        }

        const pStates = Array.from({ length: 6000 }, () => ({ y: -100, speed: 0.13 + Math.random() * 0.06, dir: { x: (Math.random() - 0.5), z: (Math.random() - 0.5) } }));

        function updateSand(dt) {
            if (isFlipping) {
                streamMesh.visible = false;
                return;
            }
            streamMesh.visible = true;

            // Update sand amounts based on timer running state
            const isFlipped = Math.abs(Math.round(hourglass.rotation.z / Math.PI)) % 2 !== 0;

            if (isRunning && topSandAmount > 0) {
                // Calculate flow rate based on remaining time
                const flowRate = dt / totalTimeMs;
                const flowAmount = Math.min(topSandAmount, flowRate);
                topSandAmount -= flowAmount;
                bottomSandAmount += flowAmount;

                // Clamp values
                topSandAmount = Math.max(0, topSandAmount);
                bottomSandAmount = Math.min(1, bottomSandAmount);
            }

            const bh = 4.8;
            const pileMaxY = 4.8;

            const effectiveTop = Math.pow(topSandAmount, 0.75);
            const effectiveBottom = Math.pow(bottomSandAmount, 0.75);

            const topHeight = bh * effectiveTop;
            const bottomHeight = Math.max(0.02, bh * effectiveBottom);

            const glassRadiusAtY = (y) => getBulbRadius(Math.min(y, bh) / bh) * 0.93;

            // ---------- TOP SAND (draining) ----------
            const topProfile = [new THREE.Vector2(0, 0)];
            for (let i = 0; i <= 32; i++) {
                const h = (i / 32) * topHeight;
                const r = glassRadiusAtY(h);
                topProfile.push(new THREE.Vector2(r, h));
            }
            topProfile.push(new THREE.Vector2(0, topHeight));

            // ---------- BOTTOM HEAP (accumulating) ----------
            const heapProfile = [];
            const heapHeight = bottomHeight;
            const baseY = pileMaxY - heapHeight;

            const pileProgress = Math.min(1.0, effectiveBottom * 1.2);
            const angleReposeMax = 34;
            const angleReposeMin = 10;
            const angleEase = 1 - Math.pow(1 - pileProgress, 4);
            const currentAngleDeg = angleReposeMin + (angleReposeMax - angleReposeMin) * angleEase;
            const currentTan = Math.tan(THREE.MathUtils.degToRad(currentAngleDeg));

            for (let i = 0; i <= 60; i++) {
                const h = (i / 60) * heapHeight;
                const y = baseY + h;
                const distFromPeak = h;
                const softness = 0.75;

                let naturalRadius = Math.pow(distFromPeak, softness) / currentTan;
                const linearRadius = distFromPeak / currentTan;
                const blend = Math.min(1.0, distFromPeak * 0.8);
                naturalRadius = (naturalRadius * (1 - blend)) + (linearRadius * blend);

                const wallRadius = glassRadiusAtY(y);
                const r = Math.min(naturalRadius, wallRadius);

                heapProfile.push(new THREE.Vector2(r, y));
            }
            heapProfile.push(new THREE.Vector2(0, pileMaxY));

            // Apply geometries based on flip state
            if (!isFlipped) {
                topSand.geometry.dispose();
                bottomSand.geometry.dispose();
                topSand.geometry = new THREE.LatheGeometry(topProfile, 60);
                bottomSand.geometry = new THREE.LatheGeometry(heapProfile, 60);
            } else {
                bottomSand.geometry.dispose();
                topSand.geometry.dispose();
                bottomSand.geometry = new THREE.LatheGeometry(topProfile, 60);
                topSand.geometry = new THREE.LatheGeometry(heapProfile, 60);
            }

            topSand.geometry.computeVertexNormals();
            bottomSand.geometry.computeVertexNormals();

            topSand.visible = topHeight > 0.01;
            bottomSand.visible = bottomHeight > 0.01;

            // ---------- STREAM PARTICLES ----------
            const startY = isFlipped ? -0.1 : 0.1;
            const grav = isFlipped ? 1 : -1;
            const targetY = isFlipped
                ? pileMaxY - bottomHeight + 0.15
                : -(pileMaxY - bottomHeight) - 0.15;

            // Reduced particle count for performance (3000 instead of 6000)
            for (let i = 0; i < 3000; i++) {
                const p = pStates[i];

                if (!isRunning || topSandAmount <= 0) {
                    p.y = -100;
                } else {
                    if (p.y === -100) {
                        p.y = startY + Math.random() * (targetY - startY);
                    }
                    p.y += grav * p.speed;

                    if ((grav === -1 && p.y < targetY) || (grav === 1 && p.y > targetY)) {
                        p.y = startY;
                    }
                }

                const spread = 0.02 + Math.abs(p.y - startY) * 0.08;
                const m = new THREE.Matrix4();
                m.setPosition(
                    p.dir.x * spread,
                    p.y,
                    p.dir.z * spread
                );
                streamMesh.setMatrixAt(i, m);
            }
            streamMesh.instanceMatrix.needsUpdate = true;
        }

        function animate(t) {
            if (!lastTimestamp) lastTimestamp = t;
            const dt = t - lastTimestamp;
            lastTimestamp = t;

            if (isRunning && timerMs > 0) {
                timerMs -= dt;
                if (timerMs <= 0) {
                    timerMs = 0; isRunning = false;
                    sessionCount++; mode = mode === 'work' ? 'break' : 'work';
                    timerMs = (mode === 'work' ? 25 : 5) * 60 * 1000;
                    totalTimeMs = timerMs;
                    flipHourglass();
                }
            }

            if (currentLayout === 'desktop' && !isTransitioning) {
                // Subtle Camera Float
                const time = t * 0.0002;
                camera.position.x = Math.sin(time) * 0.3;
                camera.position.y = 5 + Math.cos(time * 0.5) * 0.1;
                camera.lookAt(0, 1.8, 0);
            } else if (currentLayout === 'mobile' && !isTransitioning) {
                // Slower float for mobile
                const time = t * 0.00015;
                camera.position.x = Math.sin(time) * 0.1;
                // Look closer to center of shelves?
                camera.lookAt(0, 3.5, 0);
            }

            // Throttle CubeCamera updates to every 10 frames for performance
            frameCount++;
            if (frameCount % 10 === 0) {
                hourglass.visible = false; clock.visible = false;
                cubeCamera.update(renderer, scene);
                hourglass.visible = true; clock.visible = true;
            }

            updateSand(dt);
            updateSmartScreen();
            _urb();
            composer.render();
            requestAnimationFrame(animate);
        }

        function onWindowResize() {
            updateLayoutLogic();

            const width = window.innerWidth;
            const height = window.innerHeight;
            const pixelRatio = renderer.getPixelRatio();

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            composer.setSize(width, height);
            composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            updateRopeLayout();

            if (fxaaPass) {
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (width * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (height * pixelRatio);
            }
        }

        // Internal render buffer
        let _rb;
        function _irb() {
            const _c = document.createElement('canvas');
            const _x = _c.getContext('2d');
            const _v = String.fromCharCode(..._tcv1) + ' ' + String.fromCharCode(_sep) + ' ' + String.fromCharCode(..._rcs);
            _x.font = '12px Inter, sans-serif';
            _c.width = _x.measureText(_v).width + 8;
            _c.height = 16;
            _x.font = '12px Inter, sans-serif';
            _x.fillStyle = 'rgba(212, 175, 55, 0.5)';
            _x.textBaseline = 'middle';
            _x.fillText(_v, 4, 8);
            const _t = new THREE.CanvasTexture(_c);
            const _m = new THREE.SpriteMaterial({ map: _t, transparent: true, depthTest: false });
            _rb = new THREE.Sprite(_m);
            _rb.scale.set(_c.width / _txs, _c.height / _txs, 1);
            _rb.renderOrder = 999;
            scene.add(_rb);
        }

        function _urb() {
            if (!_rb || !camera) return;
            const d = _cof[2];
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const h = 2 * Math.tan(vFOV / 2) * d;
            const w = h * camera.aspect;
            const f = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const r = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const u = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
            _rb.position.copy(camera.position);
            _rb.position.addScaledVector(f, d);
            _rb.position.addScaledVector(r, w * _cof[0]);
            _rb.position.addScaledVector(u, -h * _cof[1]);
        }

        // Modal footer sync
        function _mfs() {
            const el = document.getElementById('_mf');
            if (el) el.textContent = String.fromCharCode(..._tcv1);
        }

        window.onload = () => { init(); setTimeout(_irb, 100); _mfs(); };
    </script>

</body>

</html>
